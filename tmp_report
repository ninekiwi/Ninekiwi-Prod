  const [form, setForm] = useState<FormData>(() => {
    const now = new Date();
    const base: any = {
      purposeOfFieldVisit: "",
      reportId: "",

      clientName: "",
      companyName: "",
      inspectorName: "",
      nameandAddressOfCompany: "",
      contactPhone: "",
      contactEmail: "",

      location: "",
      streetAddress: "",
      city: "",
      state: "",
      country: "",
      zipCode: "",

      lat: "",
      lon: "",

      inspectionDate: now.toISOString().split("T")[0],
      startInspectionTime: "12:00",

      temperature: "",
      humidity: "",
      windSpeed: "",
      weatherDescription: "",

      weatherConditions: "",
      safetyCompliance: "",
      safetySignage: "",
      equipmentCondition: "",
      workmanshipQuality: "",
      siteHousekeeping: "",
      communicationRating: "",

      numWorkers: "",
      workerAttendance: "",
      workProgress: "",
      scheduleCompliance: "",
      materialAvailability: "",
      maintenanceStatus: "",
      specificationCompliance: "",
      incidentsHazards: "",
      stakeholderVisits: "",

      additionalComments: "",
      inspectorSummary: "",
      recommendations: "",
      recommendationRating: "",
      improvementAreas: "",
      signatureDateTime: now.toISOString().slice(0, 16),

      weatherConditionsNote: "",
      safetyComplianceNote: "",
      safetySignageNote: "",
      equipmentConditionNote: "",
      workmanshipQualityNote: "",
      siteHousekeepingNote: "",
      communicationRatingNote: "",

      flexibleModes: {
        weatherConditions: "yesno",
        safetyCompliance: "yesno",
        safetySignage: "yesno",
        equipmentCondition: "yesno",
        workmanshipQuality: "yesno",
        siteHousekeeping: "yesno",
        communicationRating: "yesno",
      },

      // NEW fields
      backgroundManual: "",
      backgroundAuto: "",
      fieldObservationText: "",
    };
    // Merge saved form from localStorage (if any) for immediate accurate progress
    try {
      if (typeof window !== 'undefined') {
        const raw = localStorage.getItem("nk_report_form");
        if (raw) {
          const saved = JSON.parse(raw);
          if (saved && typeof saved === 'object') {
            Object.assign(base, saved);
            // ensure defaults for missing date/time fields
            base.inspectionDate = base.inspectionDate || now.toISOString().split("T")[0];
            base.startInspectionTime = base.startInspectionTime || "12:00";
            base.signatureDateTime = base.signatureDateTime || now.toISOString().slice(0, 16);
          }
        }
      }
    } catch {}
    return base as FormData;
  });

  // per-section photos (DB-aware)
  const [sectionPhotos, setSectionPhotos] = useState<Record<string, DBUPhoto[]>>({
    weather: [],
    safety: [],
    work: [],
    equipment: [],
    incidents: [],
    quality: [],
    notes: [],
    evidence: [],
    additional: [],
    // NEW buckets
    background: [],
    fieldObservation: [],
  });

  const [signatureData, setSignatureData] = useState<string | null>(null);
  const [isOnline, setIsOnline] = useState<boolean>(typeof navigator !== 'undefined' ? navigator.onLine : true);
  const [purposeTouched, setPurposeTouched] = useState<boolean>(false);
  const [mounted, setMounted] = useState(false);
  useEffect(() => { setMounted(true); }, []);

  // Map snapshot feature removed
  const [pdfGenerating, setPdfGenerating] = useState(false);
  const [pdfElapsed, setPdfElapsed] = useState(0);
  const [exportMode, setExportMode] = useState<null | 'pdf' | 'docx'>(null);
  const [disclaimerAccepted, setDisclaimerAccepted] = useState<boolean>(false);
  const [disclaimerDismissed, setDisclaimerDismissed] = useState<boolean>(false);
  
  // captureStaticMapDataUrl removed with map snapshot feature

  // Autosave and restore form progress
  useEffect(() => {
    try {
      const raw = localStorage.getItem("nk_report_form");
      let saved: any = null;
      if (raw) {
        saved = JSON.parse(raw);
        if (saved && typeof saved === "object") {
          setForm((f) => ({ ...f, ...saved }));
        }
      }
      // map state load removed
      (async () => {
        try {
          const key = draftKeyForReport((saved && saved.reportId) || form.reportId);
          const draft = await loadOfflineDraft<any>(key);
          if (draft) {
            if (draft.sectionPhotos && typeof draft.sectionPhotos === 'object') {
              setSectionPhotos((prev) => ({ ...prev, ...draft.sectionPhotos }));
            }
            if (typeof draft.signatureData !== 'undefined') setSignatureData(draft.signatureData);
            if (typeof draft.scrollY === 'number') {
              setTimeout(() => { try { window.scrollTo({ top: draft.scrollY }); } catch {} }, 300);
            }
          }
        } catch {}
      })();
    } catch {}
  }, []);

  useEffect(() => {
    try {
      const toSave: any = { ...form };
      localStorage.setItem("nk_report_form", JSON.stringify(toSave));
    } catch {}
  }, [form]);

  // Persist report to database when online and reportId is present (debounced)
  useEffect(() => {
    let to: any;
    const persist = async () => {
      try {
        const id = String(form.reportId || "").trim();
        if (!id) return;
        if (typeof navigator !== "undefined" && !navigator.onLine) return;
        await saveReport({ reportId: id, data: form as any, signatureData: signatureData ?? null });
      } catch {
        // no-op: keep UI responsive; admin lists may simply miss this save if unauthorized/offline
      }
    };
    to = setTimeout(persist, 1200);
    return () => { if (to) clearTimeout(to); };
  }, [form, signatureData]);

  // Disclaimer: show once until accepted
  useEffect(() => {
    try {
      const v = localStorage.getItem("nk_disclaimer_accepted");
      setDisclaimerAccepted(!!v);
    } catch {}
    const onKey = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setDisclaimerDismissed(true);
      }
    };
    if (typeof window !== 'undefined') {
      window.addEventListener('keydown', onKey as any);
    }
    return () => {
      if (typeof window !== 'undefined') {
        window.removeEventListener('keydown', onKey as any);
      }
    };
  }, []);
  // map state save removed

  useEffect(() => {
    let to: any;
    const save = async () => {
      const keyNow = draftKeyForReport(form.reportId);
      const payload = {
        sectionPhotos,
        signatureData,
        scrollY: typeof window !== 'undefined' ? window.scrollY : 0,
      };
      await saveOfflineDraft(keyNow, payload);
      if (!String(form.reportId || '').trim()) {
        await saveOfflineDraft(draftKeyForReport(null), payload);
      }
    };
    to = setTimeout(save, 600);
    return () => { if (to) clearTimeout(to); };
  }, [sectionPhotos, signatureData, form.reportId]);

  useEffect(() => {
    const onOnline = async () => {
      setIsOnline(true);
      try {
        const hasId = String(form.reportId || '').trim().length > 0;
        if (!hasId) return;
        // Ensure report metadata exists in DB once back online
        try {
          await saveReport({ reportId: String(form.reportId).trim(), data: form as any, signatureData: signatureData ?? null });
        } catch {}
        const keys = Object.keys(sectionPhotos || {});
        for (const k of keys) {
          try {
            const arr = (sectionPhotos as any)[k] || [];
            // @ts-ignore
            await (makePersistingSetter as any)(k)(arr);
          } catch {}
        }
      } catch {}
    };
    const onOffline = () => setIsOnline(false);
    const onBeforeUnload = () => {
      try {
        const keyNow = draftKeyForReport(form.reportId);
        void saveOfflineDraft(keyNow, { sectionPhotos, signatureData, scrollY: window.scrollY });
      } catch {}
    };
    window.addEventListener('online', onOnline);
    window.addEventListener('offline', onOffline);
    window.addEventListener('beforeunload', onBeforeUnload);
    return () => {
      window.removeEventListener('online', onOnline);
      window.removeEventListener('offline', onOffline);
      window.removeEventListener('beforeunload', onBeforeUnload);
    };
  }, [sectionPhotos, signatureData, form.reportId]);

  useEffect(() => {
    const id = String(form.reportId || '').trim();
    if (!id) return;
    (async () => {
      try {
        const draft = await loadOfflineDraft<any>(draftKeyForReport(id));
        if (draft) {
          if (draft.sectionPhotos && typeof draft.sectionPhotos === 'object') {
            setSectionPhotos((prev) => ({ ...prev, ...draft.sectionPhotos }));
          }
          if (typeof draft.signatureData !== 'undefined') setSignatureData(draft.signatureData);
        }
      } catch {}
    })();
  }, [form.reportId]);

  // Site map auto-include removed

  // If lat/lon are not available, try geocoding the address to include a site map automatically
  // Site map geocode + capture removed

  useEffect(() => {
    const now = new Date();
    setForm((f) => ({
      ...f,
      inspectionDate: f.inspectionDate || now.toISOString().split("T")[0],
      startInspectionTime: f.startInspectionTime || "12:00",
      signatureDateTime: f.signatureDateTime || now.toISOString().slice(0, 16),
    }));

    const fetchWeatherData = async () => {
      if (typeof window !== "undefined" && navigator.geolocation) {
        navigator.geolocation.getCurrentPosition((position) => {
          const { latitude, longitude } = position.coords;
          setForm((prev) => ({ ...prev, lat: String(latitude), lon: String(longitude) }));
        });
      }
    };

    fetchWeatherData();
  }, []);

  useEffect(() => {
    try {
      const idle = (cb: any) => (typeof (window as any).requestIdleCallback === 'function' ? (window as any).requestIdleCallback(cb, { timeout: 2000 }) : setTimeout(cb, 1200));
      idle(() => warmupExportLibs());
    } catch {}
  }, []);

  /* ---------------- Helpers ---------------- */

  const adaptPhotos = (arr: DBUPhoto[]): PhotoData[] =>
    (arr || []).map((p: any) => ({
      name: p.name ?? p.filename ?? "Photo",
      data: p.src ?? p.data ?? "",
      includeInSummary: !!p.includeInSummary,
      caption: p.caption ?? p.name ?? "",
      description: p.description ?? "",
      figureNumber: p.figureNumber,
    }));

  const adaptedSectionPhotos = useMemo(() => {
    const out: Record<string, PhotoData[]> = {};
    for (const key of Object.keys(sectionPhotos)) {
      out[key] = adaptPhotos(sectionPhotos[key] || []);
    }
    return out;
  }, [sectionPhotos]);

  const summaryPhotosU = useMemo(() => {
